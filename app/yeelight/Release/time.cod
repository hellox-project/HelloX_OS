; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\time.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	__lpdays
PUBLIC	__days
PUBLIC	__timezone
PUBLIC	__daylight
PUBLIC	__dstbias
PUBLIC	___dnames
PUBLIC	___mnames
_BSS	SEGMENT
_tb	DB	024H DUP (?)
_BSS	ENDS
CONST	SEGMENT
___dnames DB	'SunMonTueWedThuFriSat', 00H
	ORG $+2
___mnames DB	'JanFebMarAprMayJunJulAugSepOctNovDec', 00H
CONST	ENDS
_DATA	SEGMENT
__lpdays DD	0ffffffffH
	DD	01eH
	DD	03bH
	DD	05aH
	DD	078H
	DD	097H
	DD	0b5H
	DD	0d4H
	DD	0f3H
	DD	0111H
	DD	0130H
	DD	014eH
	DD	016dH
__days	DD	0ffffffffH
	DD	01eH
	DD	03aH
	DD	059H
	DD	077H
	DD	096H
	DD	0b4H
	DD	0d3H
	DD	0f2H
	DD	0110H
	DD	012fH
	DD	014dH
	DD	016cH
__timezone DD	07080H
__daylight DD	01H
__dstbias DD	0fffff1f0H
_DATA	ENDS
PUBLIC	_clock
PUBLIC	__time
PUBLIC	__difftime
PUBLIC	__mktime
PUBLIC	__asctime
PUBLIC	__ctime
PUBLIC	__gmtime
PUBLIC	__localtime
PUBLIC	__strftime
PUBLIC	_gettimeofday
PUBLIC	__gmtotime_t
EXTRN	_GetSystemTime:PROC
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __make_time_t
_TEXT	SEGMENT
tv174 = -44						; size = 4
tv172 = -40						; size = 4
tv159 = -36						; size = 4
tv157 = -32						; size = 4
tv144 = -28						; size = 4
tv142 = -24						; size = 4
tv76 = -20						; size = 4
_tbtemp$ = -16						; size = 4
_tmptm3$ = -12						; size = 4
_tmptm2$ = -8						; size = 4
_tmptm1$ = -4						; size = 4
_tb$ = 8						; size = 4
_ultflag$ = 12						; size = 4
__make_time_t PROC					; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 77   :  	long tmptm1, tmptm2, tmptm3;
; 78   :  	struct tm *tbtemp;
; 79   :  
; 80   :  	/*
; 81   :  	* First, make sure tm_year is reasonably close to being in range.
; 82   :  	*/
; 83   :  	if ( ((tmptm1 = tb->tm_year) < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR+ 1) )

  00008	8b 45 08	 mov	 eax, DWORD PTR _tb$[ebp]
  0000b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000e	89 4d fc	 mov	 DWORD PTR _tmptm1$[ebp], ecx
  00011	83 7d fc 45	 cmp	 DWORD PTR _tmptm1$[ebp], 69 ; 00000045H
  00015	7c 09		 jl	 SHORT $LN3@make_time_
  00017	81 7d fc 8b 00
	00 00		 cmp	 DWORD PTR _tmptm1$[ebp], 139 ; 0000008bH
  0001e	7e 05		 jle	 SHORT $LN2@make_time_
$LN3@make_time_:

; 84   :  		goto err_mktime;

  00020	e9 ff 02 00 00	 jmp	 $err_mktime$44
$LN2@make_time_:

; 85   :  
; 86   :  	/*
; 87   :  	* Adjust month value so it is in the range 0 - 11.  This is because
; 88   :  	* we don't know how many days are in months 12, 13, 14, etc.
; 89   :  	*/
; 90   :  
; 91   :  	if ( (tb->tm_mon < 0) || (tb->tm_mon > 11) ) 

  00025	8b 55 08	 mov	 edx, DWORD PTR _tb$[ebp]
  00028	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0002c	7c 09		 jl	 SHORT $LN5@make_time_
  0002e	8b 45 08	 mov	 eax, DWORD PTR _tb$[ebp]
  00031	83 78 10 0b	 cmp	 DWORD PTR [eax+16], 11	; 0000000bH
  00035	7e 60		 jle	 SHORT $LN4@make_time_
$LN5@make_time_:

; 92   :  	{
; 93   :   		/*
; 94   :  		* no danger of overflow because the range check above.
; 95   :  		*/
; 96   :  		tmptm1 += (tb->tm_mon / 12);

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _tb$[ebp]
  0003a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0003d	99		 cdq
  0003e	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00043	f7 f9		 idiv	 ecx
  00045	03 45 fc	 add	 eax, DWORD PTR _tmptm1$[ebp]
  00048	89 45 fc	 mov	 DWORD PTR _tmptm1$[ebp], eax

; 97   :  
; 98   :  		if ( (tb->tm_mon %= 12) < 0 ) 

  0004b	8b 55 08	 mov	 edx, DWORD PTR _tb$[ebp]
  0004e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00051	99		 cdq
  00052	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00057	f7 f9		 idiv	 ecx
  00059	89 55 ec	 mov	 DWORD PTR tv76[ebp], edx
  0005c	8b 55 08	 mov	 edx, DWORD PTR _tb$[ebp]
  0005f	8b 45 ec	 mov	 eax, DWORD PTR tv76[ebp]
  00062	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00065	83 7d ec 00	 cmp	 DWORD PTR tv76[ebp], 0
  00069	7d 18		 jge	 SHORT $LN6@make_time_

; 99   :  		{
; 100  :  			tb->tm_mon += 12;

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _tb$[ebp]
  0006e	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00071	83 c2 0c	 add	 edx, 12			; 0000000cH
  00074	8b 45 08	 mov	 eax, DWORD PTR _tb$[ebp]
  00077	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 101  :  			tmptm1--;

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _tmptm1$[ebp]
  0007d	83 e9 01	 sub	 ecx, 1
  00080	89 4d fc	 mov	 DWORD PTR _tmptm1$[ebp], ecx
$LN6@make_time_:

; 102  :  		}
; 103  :  
; 104  :  		/*
; 105  :  		* Make sure year count is still in range.
; 106  :  		*/
; 107  :  		if ( (tmptm1 < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR + 1) )

  00083	83 7d fc 45	 cmp	 DWORD PTR _tmptm1$[ebp], 69 ; 00000045H
  00087	7c 09		 jl	 SHORT $LN8@make_time_
  00089	81 7d fc 8b 00
	00 00		 cmp	 DWORD PTR _tmptm1$[ebp], 139 ; 0000008bH
  00090	7e 05		 jle	 SHORT $LN4@make_time_
$LN8@make_time_:

; 108  :  			goto err_mktime;

  00092	e9 8d 02 00 00	 jmp	 $err_mktime$44
$LN4@make_time_:

; 109  :  	}
; 110  :  
; 111  :  	/***** HERE: tmptm1 holds number of elapsed years *****/
; 112  :  
; 113  :  	/*
; 114  :  	* Calculate days elapsed minus one, in the given year, to the given
; 115  :  	* month. Check for leap year and adjust if necessary.
; 116  :  	*/
; 117  :  	tmptm2 = _days[tb->tm_mon];

  00097	8b 55 08	 mov	 edx, DWORD PTR _tb$[ebp]
  0009a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0009d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR __days[eax*4]
  000a4	89 4d f8	 mov	 DWORD PTR _tmptm2$[ebp], ecx

; 118  :  	if ( !(tmptm1 & 3) && (tb->tm_mon > 1) )

  000a7	8b 55 fc	 mov	 edx, DWORD PTR _tmptm1$[ebp]
  000aa	83 e2 03	 and	 edx, 3
  000ad	75 12		 jne	 SHORT $LN9@make_time_
  000af	8b 45 08	 mov	 eax, DWORD PTR _tb$[ebp]
  000b2	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  000b6	7e 09		 jle	 SHORT $LN9@make_time_

; 119  :  		tmptm2++;

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _tmptm2$[ebp]
  000bb	83 c1 01	 add	 ecx, 1
  000be	89 4d f8	 mov	 DWORD PTR _tmptm2$[ebp], ecx
$LN9@make_time_:

; 120  :  
; 121  :  	/*
; 122  :  	* Calculate elapsed days since base date (midnight, 1/1/70, UTC)
; 123  :  	*
; 124  :  	*
; 125  :  	* 365 days for each elapsed year since 1970, plus one more day for
; 126  :  	* each elapsed leap year. no danger of overflow because of the range
; 127  :  	* check (above) on tmptm1.
; 128  :  	*/
; 129  :  	tmptm3 = (tmptm1 - _BASE_YEAR) * 365L + ((tmptm1 - 1L) >> 2) - _LEAP_YEAR_ADJUST;

  000c1	8b 55 fc	 mov	 edx, DWORD PTR _tmptm1$[ebp]
  000c4	83 ea 46	 sub	 edx, 70			; 00000046H
  000c7	69 c2 6d 01 00
	00		 imul	 eax, edx, 365
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _tmptm1$[ebp]
  000d0	83 e9 01	 sub	 ecx, 1
  000d3	c1 f9 02	 sar	 ecx, 2
  000d6	8d 54 08 ef	 lea	 edx, DWORD PTR [eax+ecx-17]
  000da	89 55 f4	 mov	 DWORD PTR _tmptm3$[ebp], edx

; 130  :  
; 131  :  	/*
; 132  :  	* elapsed days to current month (still no possible overflow)
; 133  :  	*/
; 134  :  	tmptm3 += tmptm2; 

  000dd	8b 45 f4	 mov	 eax, DWORD PTR _tmptm3$[ebp]
  000e0	03 45 f8	 add	 eax, DWORD PTR _tmptm2$[ebp]
  000e3	89 45 f4	 mov	 DWORD PTR _tmptm3$[ebp], eax

; 135  :  	/*
; 136  :  	* elapsed days to current date. overflow is now possible.
; 137  :  	*/
; 138  :  	tmptm1 = tmptm3 + (tmptm2 = (long)(tb->tm_mday));

  000e6	8b 4d 08	 mov	 ecx, DWORD PTR _tb$[ebp]
  000e9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ec	89 55 f8	 mov	 DWORD PTR _tmptm2$[ebp], edx
  000ef	8b 45 f4	 mov	 eax, DWORD PTR _tmptm3$[ebp]
  000f2	03 45 f8	 add	 eax, DWORD PTR _tmptm2$[ebp]
  000f5	89 45 fc	 mov	 DWORD PTR _tmptm1$[ebp], eax

; 139  :  	if ( ChkAdd(tmptm1, tmptm3, tmptm2) )

  000f8	83 7d f4 00	 cmp	 DWORD PTR _tmptm3$[ebp], 0
  000fc	7c 0c		 jl	 SHORT $LN12@make_time_
  000fe	83 7d f8 00	 cmp	 DWORD PTR _tmptm2$[ebp], 0
  00102	7c 06		 jl	 SHORT $LN12@make_time_
  00104	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  00108	7c 12		 jl	 SHORT $LN11@make_time_
$LN12@make_time_:
  0010a	83 7d f4 00	 cmp	 DWORD PTR _tmptm3$[ebp], 0
  0010e	7d 11		 jge	 SHORT $LN10@make_time_
  00110	83 7d f8 00	 cmp	 DWORD PTR _tmptm2$[ebp], 0
  00114	7d 0b		 jge	 SHORT $LN10@make_time_
  00116	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  0011a	7c 05		 jl	 SHORT $LN10@make_time_
$LN11@make_time_:

; 140  :  		goto err_mktime;

  0011c	e9 03 02 00 00	 jmp	 $err_mktime$44
$LN10@make_time_:

; 141  :  
; 142  :  	/*
; 143  :  	* Calculate elapsed hours since base date
; 144  :  	*/
; 145  : 
; 146  :  	tmptm2 = tmptm1 * 24L;

  00121	6b 4d fc 18	 imul	 ecx, DWORD PTR _tmptm1$[ebp], 24
  00125	89 4d f8	 mov	 DWORD PTR _tmptm2$[ebp], ecx

; 147  :  	if ( ChkMul(tmptm2, tmptm1, 24L) )

  00128	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  0012c	74 24		 je	 SHORT $LN34@make_time_
  0012e	8b 45 f8	 mov	 eax, DWORD PTR _tmptm2$[ebp]
  00131	99		 cdq
  00132	f7 7d fc	 idiv	 DWORD PTR _tmptm1$[ebp]
  00135	83 f8 18	 cmp	 eax, 24			; 00000018H
  00138	74 09		 je	 SHORT $LN32@make_time_
  0013a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv142[ebp], 1
  00141	eb 07		 jmp	 SHORT $LN33@make_time_
$LN32@make_time_:
  00143	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$LN33@make_time_:
  0014a	8b 55 e8	 mov	 edx, DWORD PTR tv142[ebp]
  0014d	89 55 e4	 mov	 DWORD PTR tv144[ebp], edx
  00150	eb 07		 jmp	 SHORT $LN35@make_time_
$LN34@make_time_:
  00152	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv144[ebp], 0
$LN35@make_time_:
  00159	83 7d e4 00	 cmp	 DWORD PTR tv144[ebp], 0
  0015d	74 05		 je	 SHORT $LN13@make_time_

; 148  :  		goto err_mktime;

  0015f	e9 c0 01 00 00	 jmp	 $err_mktime$44
$LN13@make_time_:

; 149  :  
; 150  :  	tmptm1 = tmptm2 + (tmptm3 = (long)tb->tm_hour);

  00164	8b 45 08	 mov	 eax, DWORD PTR _tb$[ebp]
  00167	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0016a	89 4d f4	 mov	 DWORD PTR _tmptm3$[ebp], ecx
  0016d	8b 55 f8	 mov	 edx, DWORD PTR _tmptm2$[ebp]
  00170	03 55 f4	 add	 edx, DWORD PTR _tmptm3$[ebp]
  00173	89 55 fc	 mov	 DWORD PTR _tmptm1$[ebp], edx

; 151  :  	if ( ChkAdd(tmptm1, tmptm2, tmptm3) )

  00176	83 7d f8 00	 cmp	 DWORD PTR _tmptm2$[ebp], 0
  0017a	7c 0c		 jl	 SHORT $LN16@make_time_
  0017c	83 7d f4 00	 cmp	 DWORD PTR _tmptm3$[ebp], 0
  00180	7c 06		 jl	 SHORT $LN16@make_time_
  00182	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  00186	7c 12		 jl	 SHORT $LN15@make_time_
$LN16@make_time_:
  00188	83 7d f8 00	 cmp	 DWORD PTR _tmptm2$[ebp], 0
  0018c	7d 11		 jge	 SHORT $LN14@make_time_
  0018e	83 7d f4 00	 cmp	 DWORD PTR _tmptm3$[ebp], 0
  00192	7d 0b		 jge	 SHORT $LN14@make_time_
  00194	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  00198	7c 05		 jl	 SHORT $LN14@make_time_
$LN15@make_time_:

; 152  :  		goto err_mktime;

  0019a	e9 85 01 00 00	 jmp	 $err_mktime$44
$LN14@make_time_:

; 153  :  
; 154  :  	/*
; 155  :  	* Calculate elapsed minutes since base date
; 156  :  	*/
; 157  :  
; 158  :  	tmptm2 = tmptm1 * 60L;

  0019f	6b 45 fc 3c	 imul	 eax, DWORD PTR _tmptm1$[ebp], 60
  001a3	89 45 f8	 mov	 DWORD PTR _tmptm2$[ebp], eax

; 159  :  	if ( ChkMul(tmptm2, tmptm1, 60L) )

  001a6	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  001aa	74 24		 je	 SHORT $LN38@make_time_
  001ac	8b 45 f8	 mov	 eax, DWORD PTR _tmptm2$[ebp]
  001af	99		 cdq
  001b0	f7 7d fc	 idiv	 DWORD PTR _tmptm1$[ebp]
  001b3	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  001b6	74 09		 je	 SHORT $LN36@make_time_
  001b8	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv157[ebp], 1
  001bf	eb 07		 jmp	 SHORT $LN37@make_time_
$LN36@make_time_:
  001c1	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv157[ebp], 0
$LN37@make_time_:
  001c8	8b 4d e0	 mov	 ecx, DWORD PTR tv157[ebp]
  001cb	89 4d dc	 mov	 DWORD PTR tv159[ebp], ecx
  001ce	eb 07		 jmp	 SHORT $LN39@make_time_
$LN38@make_time_:
  001d0	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv159[ebp], 0
$LN39@make_time_:
  001d7	83 7d dc 00	 cmp	 DWORD PTR tv159[ebp], 0
  001db	74 05		 je	 SHORT $LN17@make_time_

; 160  :  		goto err_mktime;

  001dd	e9 42 01 00 00	 jmp	 $err_mktime$44
$LN17@make_time_:

; 161  :  
; 162  :  	tmptm1 = tmptm2 + (tmptm3 = (long)tb->tm_min);

  001e2	8b 55 08	 mov	 edx, DWORD PTR _tb$[ebp]
  001e5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e8	89 45 f4	 mov	 DWORD PTR _tmptm3$[ebp], eax
  001eb	8b 4d f8	 mov	 ecx, DWORD PTR _tmptm2$[ebp]
  001ee	03 4d f4	 add	 ecx, DWORD PTR _tmptm3$[ebp]
  001f1	89 4d fc	 mov	 DWORD PTR _tmptm1$[ebp], ecx

; 163  :  	if ( ChkAdd(tmptm1, tmptm2, tmptm3) )

  001f4	83 7d f8 00	 cmp	 DWORD PTR _tmptm2$[ebp], 0
  001f8	7c 0c		 jl	 SHORT $LN20@make_time_
  001fa	83 7d f4 00	 cmp	 DWORD PTR _tmptm3$[ebp], 0
  001fe	7c 06		 jl	 SHORT $LN20@make_time_
  00200	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  00204	7c 12		 jl	 SHORT $LN19@make_time_
$LN20@make_time_:
  00206	83 7d f8 00	 cmp	 DWORD PTR _tmptm2$[ebp], 0
  0020a	7d 11		 jge	 SHORT $LN18@make_time_
  0020c	83 7d f4 00	 cmp	 DWORD PTR _tmptm3$[ebp], 0
  00210	7d 0b		 jge	 SHORT $LN18@make_time_
  00212	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  00216	7c 05		 jl	 SHORT $LN18@make_time_
$LN19@make_time_:

; 164  :  		goto err_mktime;

  00218	e9 07 01 00 00	 jmp	 $err_mktime$44
$LN18@make_time_:

; 165  :  
; 166  :  	/***** HERE: tmptm1 holds number of elapsed minutes *****/
; 167  :  
; 168  :  	/*
; 169  :  	* Calculate elapsed seconds since base date
; 170  :  	*/
; 171  :  
; 172  :  	tmptm2 = tmptm1 * 60L;

  0021d	6b 55 fc 3c	 imul	 edx, DWORD PTR _tmptm1$[ebp], 60
  00221	89 55 f8	 mov	 DWORD PTR _tmptm2$[ebp], edx

; 173  :  	if ( ChkMul(tmptm2, tmptm1, 60L) )

  00224	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  00228	74 24		 je	 SHORT $LN42@make_time_
  0022a	8b 45 f8	 mov	 eax, DWORD PTR _tmptm2$[ebp]
  0022d	99		 cdq
  0022e	f7 7d fc	 idiv	 DWORD PTR _tmptm1$[ebp]
  00231	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  00234	74 09		 je	 SHORT $LN40@make_time_
  00236	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv172[ebp], 1
  0023d	eb 07		 jmp	 SHORT $LN41@make_time_
$LN40@make_time_:
  0023f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv172[ebp], 0
$LN41@make_time_:
  00246	8b 45 d8	 mov	 eax, DWORD PTR tv172[ebp]
  00249	89 45 d4	 mov	 DWORD PTR tv174[ebp], eax
  0024c	eb 07		 jmp	 SHORT $LN43@make_time_
$LN42@make_time_:
  0024e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv174[ebp], 0
$LN43@make_time_:
  00255	83 7d d4 00	 cmp	 DWORD PTR tv174[ebp], 0
  00259	74 05		 je	 SHORT $LN21@make_time_

; 174  :  		goto err_mktime;

  0025b	e9 c4 00 00 00	 jmp	 $err_mktime$44
$LN21@make_time_:

; 175  :  
; 176  :  	tmptm1 = tmptm2 + (tmptm3 = (long)tb->tm_sec);

  00260	8b 4d 08	 mov	 ecx, DWORD PTR _tb$[ebp]
  00263	8b 11		 mov	 edx, DWORD PTR [ecx]
  00265	89 55 f4	 mov	 DWORD PTR _tmptm3$[ebp], edx
  00268	8b 45 f8	 mov	 eax, DWORD PTR _tmptm2$[ebp]
  0026b	03 45 f4	 add	 eax, DWORD PTR _tmptm3$[ebp]
  0026e	89 45 fc	 mov	 DWORD PTR _tmptm1$[ebp], eax

; 177  :  	if ( ChkAdd(tmptm1, tmptm2, tmptm3) )

  00271	83 7d f8 00	 cmp	 DWORD PTR _tmptm2$[ebp], 0
  00275	7c 0c		 jl	 SHORT $LN24@make_time_
  00277	83 7d f4 00	 cmp	 DWORD PTR _tmptm3$[ebp], 0
  0027b	7c 06		 jl	 SHORT $LN24@make_time_
  0027d	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  00281	7c 12		 jl	 SHORT $LN23@make_time_
$LN24@make_time_:
  00283	83 7d f8 00	 cmp	 DWORD PTR _tmptm2$[ebp], 0
  00287	7d 11		 jge	 SHORT $LN22@make_time_
  00289	83 7d f4 00	 cmp	 DWORD PTR _tmptm3$[ebp], 0
  0028d	7d 0b		 jge	 SHORT $LN22@make_time_
  0028f	83 7d fc 00	 cmp	 DWORD PTR _tmptm1$[ebp], 0
  00293	7c 05		 jl	 SHORT $LN22@make_time_
$LN23@make_time_:

; 178  :  		goto err_mktime;

  00295	e9 8a 00 00 00	 jmp	 $err_mktime$44
$LN22@make_time_:

; 179  :  
; 180  :  	/***** HERE: tmptm1 holds number of elapsed seconds *****/
; 181  :  
; 182  :  	if  ( ultflag ) 

  0029a	83 7d 0c 00	 cmp	 DWORD PTR _ultflag$[ebp], 0
  0029e	74 5b		 je	 SHORT $LN25@make_time_

; 183  :  	{
; 184  :  
; 185  :  		/*
; 186  :  		* Adjust for timezone. No need to check for overflow since
; 187  :  		* localtime() will check its arg value
; 188  :  		*/
; 189  :  
; 190  :  		tmptm1 += _timezone;

  002a0	8b 4d fc	 mov	 ecx, DWORD PTR _tmptm1$[ebp]
  002a3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR __timezone
  002a9	89 4d fc	 mov	 DWORD PTR _tmptm1$[ebp], ecx

; 191  :  
; 192  :  		/*
; 193  :  		* Convert this second count back into a time block structure.
; 194  :  		* If localtime returns NULL, return an error.
; 195  :  		*/
; 196  :  		if ( (tbtemp = _localtime(&tmptm1)) == NULL )

  002ac	8d 55 fc	 lea	 edx, DWORD PTR _tmptm1$[ebp]
  002af	52		 push	 edx
  002b0	e8 00 00 00 00	 call	 __localtime
  002b5	83 c4 04	 add	 esp, 4
  002b8	89 45 f0	 mov	 DWORD PTR _tbtemp$[ebp], eax
  002bb	83 7d f0 00	 cmp	 DWORD PTR _tbtemp$[ebp], 0
  002bf	75 02		 jne	 SHORT $LN27@make_time_

; 197  :  			goto err_mktime;

  002c1	eb 61		 jmp	 SHORT $err_mktime$44
$LN27@make_time_:

; 198  :  
; 199  :  		/*
; 200  :  		* Now must compensate for DST. The ANSI rules are to use the
; 201  :  		* passed-in tm_isdst flag if it is non-negative. Otherwise,
; 202  :  		* compute if DST applies. Recall that tbtemp has the time without
; 203  :  		* DST compensation, but has set tm_isdst correctly.
; 204  :  		*/
; 205  :  		if ( (tb->tm_isdst > 0) || ((tb->tm_isdst < 0) && (tbtemp->tm_isdst > 0)) ) 

  002c3	8b 45 08	 mov	 eax, DWORD PTR _tb$[ebp]
  002c6	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  002ca	7f 12		 jg	 SHORT $LN29@make_time_
  002cc	8b 4d 08	 mov	 ecx, DWORD PTR _tb$[ebp]
  002cf	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  002d3	7d 24		 jge	 SHORT $LN28@make_time_
  002d5	8b 55 f0	 mov	 edx, DWORD PTR _tbtemp$[ebp]
  002d8	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  002dc	7e 1b		 jle	 SHORT $LN28@make_time_
$LN29@make_time_:

; 206  : 		{
; 207  :  				tmptm1 += _dstbias;

  002de	8b 45 fc	 mov	 eax, DWORD PTR _tmptm1$[ebp]
  002e1	03 05 00 00 00
	00		 add	 eax, DWORD PTR __dstbias
  002e7	89 45 fc	 mov	 DWORD PTR _tmptm1$[ebp], eax

; 208  :  				tbtemp = _localtime(&tmptm1);    /* reconvert, can't get NULL */

  002ea	8d 4d fc	 lea	 ecx, DWORD PTR _tmptm1$[ebp]
  002ed	51		 push	 ecx
  002ee	e8 00 00 00 00	 call	 __localtime
  002f3	83 c4 04	 add	 esp, 4
  002f6	89 45 f0	 mov	 DWORD PTR _tbtemp$[ebp], eax
$LN28@make_time_:

; 209  :  		}
; 210  :  
; 211  :  	}

  002f9	eb 17		 jmp	 SHORT $LN26@make_time_
$LN25@make_time_:

; 212  :  	else 
; 213  :  	{
; 214  :  		if ( (tbtemp = _gmtime(&tmptm1)) == NULL )

  002fb	8d 55 fc	 lea	 edx, DWORD PTR _tmptm1$[ebp]
  002fe	52		 push	 edx
  002ff	e8 00 00 00 00	 call	 __gmtime
  00304	83 c4 04	 add	 esp, 4
  00307	89 45 f0	 mov	 DWORD PTR _tbtemp$[ebp], eax
  0030a	83 7d f0 00	 cmp	 DWORD PTR _tbtemp$[ebp], 0
  0030e	75 02		 jne	 SHORT $LN26@make_time_

; 215  :  			goto err_mktime;

  00310	eb 12		 jmp	 SHORT $err_mktime$44
$LN26@make_time_:

; 216  :  	}
; 217  :  
; 218  :  
; 219  :  	*tb = *tbtemp;

  00312	b9 09 00 00 00	 mov	 ecx, 9
  00317	8b 75 f0	 mov	 esi, DWORD PTR _tbtemp$[ebp]
  0031a	8b 7d 08	 mov	 edi, DWORD PTR _tb$[ebp]
  0031d	f3 a5		 rep movsd

; 220  :  
; 221  :  	return (time_t)tmptm1;

  0031f	8b 45 fc	 mov	 eax, DWORD PTR _tmptm1$[ebp]
  00322	eb 02		 jmp	 SHORT $LN1@make_time_
$err_mktime$44:

; 222  :  
; 223  :  err_mktime:
; 224  :  	/*
; 225  :  	* All errors come to here
; 226  :  	*/
; 227  : //return (time_t)(-1);
; 228  : 
; 229  : return 0;

  00324	33 c0		 xor	 eax, eax
$LN1@make_time_:

; 230  : }

  00326	5f		 pop	 edi
  00327	5e		 pop	 esi
  00328	8b e5		 mov	 esp, ebp
  0032a	5d		 pop	 ebp
  0032b	c3		 ret	 0
__make_time_t ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __gmtotime_t
_TEXT	SEGMENT
_tb$ = -48						; size = 36
tv93 = -12						; size = 4
_tmpdays$ = -8						; size = 4
_tmptim$ = -4						; size = 4
_yr$ = 8						; size = 4
_mo$ = 12						; size = 4
_dy$ = 16						; size = 4
_hr$ = 20						; size = 4
_mn$ = 24						; size = 4
_sc$ = 28						; size = 4
__gmtotime_t PROC					; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 9    :  	int tmpdays;
; 10   :  	long tmptim;
; 11   :  	struct tm tb;
; 12   :  
; 13   :  	/*
; 14   :  	* Do a quick range check on the year and convert it to a delta
; 15   :  	* off of 1900.
; 16   :  	*/
; 17   :  	if ( ((long)(yr -= 1900) < _BASE_YEAR) || ((long)yr > _MAX_YEAR) )

  00006	8b 45 08	 mov	 eax, DWORD PTR _yr$[ebp]
  00009	2d 6c 07 00 00	 sub	 eax, 1900		; 0000076cH
  0000e	89 45 08	 mov	 DWORD PTR _yr$[ebp], eax
  00011	83 7d 08 46	 cmp	 DWORD PTR _yr$[ebp], 70	; 00000046H
  00015	7c 09		 jl	 SHORT $LN3@gmtotime_t
  00017	81 7d 08 8a 00
	00 00		 cmp	 DWORD PTR _yr$[ebp], 138 ; 0000008aH
  0001e	7e 08		 jle	 SHORT $LN2@gmtotime_t
$LN3@gmtotime_t:

; 18   :  	{
; 19   :  		return (time_t)(-1);

  00020	83 c8 ff	 or	 eax, -1
  00023	e9 b0 00 00 00	 jmp	 $LN1@gmtotime_t
$LN2@gmtotime_t:

; 20   :  	}
; 21   :  
; 22   :  	tmpdays = dy + _days[mo - 1];

  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _mo$[ebp]
  0002b	8b 55 10	 mov	 edx, DWORD PTR _dy$[ebp]
  0002e	03 14 8d fc ff
	ff ff		 add	 edx, DWORD PTR __days[ecx*4-4]
  00035	89 55 f8	 mov	 DWORD PTR _tmpdays$[ebp], edx

; 23   :  	if ( !(yr & 3) && (mo > 2) )

  00038	8b 45 08	 mov	 eax, DWORD PTR _yr$[ebp]
  0003b	83 e0 03	 and	 eax, 3
  0003e	75 0f		 jne	 SHORT $LN4@gmtotime_t
  00040	83 7d 0c 02	 cmp	 DWORD PTR _mo$[ebp], 2
  00044	7e 09		 jle	 SHORT $LN4@gmtotime_t

; 24   :  	{
; 25   :  		tmpdays++;

  00046	8b 4d f8	 mov	 ecx, DWORD PTR _tmpdays$[ebp]
  00049	83 c1 01	 add	 ecx, 1
  0004c	89 4d f8	 mov	 DWORD PTR _tmpdays$[ebp], ecx
$LN4@gmtotime_t:

; 26   :  	}
; 27   :  
; 28   :  	/*
; 29   :  	* Compute the number of elapsed seconds since the Epoch. Note the
; 30   :  	* computation of elapsed leap years would break down after 2100
; 31   :  	* if such values were in range (fortunately, they aren't).
; 32   :  	*/
; 33   :  
; 34   :  	tmptim = (long)yr - _BASE_YEAR;

  0004f	8b 55 08	 mov	 edx, DWORD PTR _yr$[ebp]
  00052	83 ea 46	 sub	 edx, 70			; 00000046H
  00055	89 55 fc	 mov	 DWORD PTR _tmptim$[ebp], edx

; 35   :  
; 36   :  	tmptim = /* 365 days for each year */

  00058	69 45 fc 6d 01
	00 00		 imul	 eax, DWORD PTR _tmptim$[ebp], 365
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _yr$[ebp]
  00062	83 e9 01	 sub	 ecx, 1
  00065	c1 f9 02	 sar	 ecx, 2
  00068	03 45 f8	 add	 eax, DWORD PTR _tmpdays$[ebp]
  0006b	8d 54 01 ef	 lea	 edx, DWORD PTR [ecx+eax-17]
  0006f	6b c2 18	 imul	 eax, edx, 24
  00072	03 45 14	 add	 eax, DWORD PTR _hr$[ebp]
  00075	6b c8 3c	 imul	 ecx, eax, 60
  00078	03 4d 18	 add	 ecx, DWORD PTR _mn$[ebp]
  0007b	6b d1 3c	 imul	 edx, ecx, 60
  0007e	03 55 1c	 add	 edx, DWORD PTR _sc$[ebp]
  00081	89 55 fc	 mov	 DWORD PTR _tmptim$[ebp], edx

; 37   :  		( ( ( ( tmptim ) * 365L
; 38   :  
; 39   :  		/* one day for each elapsed leap year */
; 40   :  		+ ((long)(yr - 1) >> 2) - (long)_LEAP_YEAR_ADJUST
; 41   :  
; 42   :  		/* number of elapsed days in yr */
; 43   :  		+ (long)tmpdays )
; 44   :  
; 45   :  		/* convert to hours and add in hr */
; 46   :  		* 24L + (long)hr )
; 47   :  
; 48   :  		/* convert to minutes and add in mn */
; 49   :  		* 60L + (long)mn )
; 50   :  
; 51   :  		/* convert to seconds and add in sec */
; 52   :  		* 60L + (long)sc;
; 53   :  
; 54   :  	//_tzset();
; 55   :  	tmptim += _timezone;        //timezone adjustment

  00084	8b 45 fc	 mov	 eax, DWORD PTR _tmptim$[ebp]
  00087	03 05 00 00 00
	00		 add	 eax, DWORD PTR __timezone
  0008d	89 45 fc	 mov	 DWORD PTR _tmptim$[ebp], eax

; 56   :  
; 57   :  	/*
; 58   :  	* Fill in enough fields of tb struct for _isindst(), then call it to
; 59   :  	* determine DST.
; 60   :  	*/
; 61   :  	tb.tm_yday = tmpdays;

  00090	8b 4d f8	 mov	 ecx, DWORD PTR _tmpdays$[ebp]
  00093	89 4d ec	 mov	 DWORD PTR _tb$[ebp+28], ecx

; 62   :  	tb.tm_year = yr;

  00096	8b 55 08	 mov	 edx, DWORD PTR _yr$[ebp]
  00099	89 55 e4	 mov	 DWORD PTR _tb$[ebp+20], edx

; 63   :  	tb.tm_mon = mo - 1;

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _mo$[ebp]
  0009f	83 e8 01	 sub	 eax, 1
  000a2	89 45 e0	 mov	 DWORD PTR _tb$[ebp+16], eax

; 64   :  	tb.tm_hour = hr;

  000a5	8b 4d 14	 mov	 ecx, DWORD PTR _hr$[ebp]
  000a8	89 4d d8	 mov	 DWORD PTR _tb$[ebp+8], ecx

; 65   :  
; 66   :  	if (_daylight)// && _isindst(&tb)

  000ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR __daylight, 0
  000b2	74 0c		 je	 SHORT $LN5@gmtotime_t

; 67   :  	{
; 68   :  		tmptim -= 3600L;

  000b4	8b 55 fc	 mov	 edx, DWORD PTR _tmptim$[ebp]
  000b7	81 ea 10 0e 00
	00		 sub	 edx, 3600		; 00000e10H
  000bd	89 55 fc	 mov	 DWORD PTR _tmptim$[ebp], edx
$LN5@gmtotime_t:

; 69   :  	}
; 70   :  
; 71   :  	return (tmptim >= 0) ? (time_t)tmptim : (time_t)(-1);

  000c0	83 7d fc 00	 cmp	 DWORD PTR _tmptim$[ebp], 0
  000c4	7c 08		 jl	 SHORT $LN7@gmtotime_t
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _tmptim$[ebp]
  000c9	89 45 f4	 mov	 DWORD PTR tv93[ebp], eax
  000cc	eb 07		 jmp	 SHORT $LN8@gmtotime_t
$LN7@gmtotime_t:
  000ce	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR tv93[ebp], -1
$LN8@gmtotime_t:
  000d5	8b 45 f4	 mov	 eax, DWORD PTR tv93[ebp]
$LN1@gmtotime_t:

; 72   : }

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
__gmtotime_t ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT _gettimeofday
_TEXT	SEGMENT
_t$1 = -4						; size = 4
_tp$ = 8						; size = 4
_tzp$ = 12						; size = 4
_gettimeofday PROC					; COMDAT

; 496  :  {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 497  : 	 //Just return the million seconds,it's a simplified implementation.
; 498  : 	 if (tp)

  00004	83 7d 08 00	 cmp	 DWORD PTR _tp$[ebp], 0
  00008	74 1f		 je	 SHORT $LN2@gettimeofd

; 499  : 	 {
; 500  : 		 time_t t = _time(NULL);

  0000a	6a 00		 push	 0
  0000c	e8 00 00 00 00	 call	 __time
  00011	83 c4 04	 add	 esp, 4
  00014	89 45 fc	 mov	 DWORD PTR _t$1[ebp], eax

; 501  : 		 tp->tv_sec = (long)t;

  00017	8b 45 08	 mov	 eax, DWORD PTR _tp$[ebp]
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _t$1[ebp]
  0001d	89 08		 mov	 DWORD PTR [eax], ecx

; 502  : 		 tp->tv_usec = 0;

  0001f	8b 55 08	 mov	 edx, DWORD PTR _tp$[ebp]
  00022	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN2@gettimeofd:

; 503  : 	 }
; 504  : 	 if (tzp)

  00029	83 7d 0c 00	 cmp	 DWORD PTR _tzp$[ebp], 0
  0002d	74 13		 je	 SHORT $LN3@gettimeofd

; 505  : 	 {
; 506  : 		 tzp->tz_dsttime = 0;

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _tzp$[ebp]
  00032	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 507  : 		 tzp->tz_minuteswest = 0;

  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _tzp$[ebp]
  0003c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN3@gettimeofd:

; 508  : 	 }
; 509  : 	 return 0;

  00042	33 c0		 xor	 eax, eax

; 510  :  }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_gettimeofday ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __strftime
_TEXT	SEGMENT
_s$ = 8							; size = 4
_size$ = 12						; size = 4
_fmt$ = 16						; size = 4
_tp$ = 20						; size = 4
__strftime PROC						; COMDAT

; 480  :  {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  :  	return 0;

  00003	33 c0		 xor	 eax, eax

; 482  :  }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
__strftime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __localtime
_TEXT	SEGMENT
tv162 = -12						; size = 4
_ltime$ = -8						; size = 4
_ptm$ = -4						; size = 4
_ptime$ = 8						; size = 4
__localtime PROC					; COMDAT

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 333  : 	struct tm *ptm;
; 334  : 	long ltime;
; 335  : 
; 336  : 	if ( (long)*ptime < 0 )

  00006	8b 45 08	 mov	 eax, DWORD PTR _ptime$[ebp]
  00009	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000c	7d 07		 jge	 SHORT $LN2@localtime

; 337  : 	{
; 338  : 		return  NULL;

  0000e	33 c0		 xor	 eax, eax
  00010	e9 12 02 00 00	 jmp	 $LN1@localtime
$LN2@localtime:

; 339  : 	}
; 340  : 
; 341  : 
; 342  : 	if ( (*ptime > 3 * _DAY_SEC) && (*ptime < LONG_MAX - 3 * _DAY_SEC) ) 

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _ptime$[ebp]
  00018	81 39 80 f4 03
	00		 cmp	 DWORD PTR [ecx], 259200	; 0003f480H
  0001e	7e 5b		 jle	 SHORT $LN3@localtime
  00020	8b 55 08	 mov	 edx, DWORD PTR _ptime$[ebp]
  00023	81 3a 7f 0b fc
	7f		 cmp	 DWORD PTR [edx], 2147224447 ; 7ffc0b7fH
  00029	7d 50		 jge	 SHORT $LN3@localtime

; 343  : 	{
; 344  : 
; 345  : 
; 346  : 		ltime = (long)*ptime - _timezone;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _ptime$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR __timezone
  00036	89 4d f8	 mov	 DWORD PTR _ltime$[ebp], ecx

; 347  : 		ptm = _gmtime( (time_t *)&ltime );

  00039	8d 55 f8	 lea	 edx, DWORD PTR _ltime$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 __gmtime
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 fc	 mov	 DWORD PTR _ptm$[ebp], eax

; 348  : 
; 349  : 
; 350  : 		if ( _daylight ) 

  00048	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR __daylight, 0
  0004f	74 25		 je	 SHORT $LN5@localtime

; 351  : 		{
; 352  : 			ltime -= _dstbias;

  00051	8b 45 f8	 mov	 eax, DWORD PTR _ltime$[ebp]
  00054	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR __dstbias
  0005a	89 45 f8	 mov	 DWORD PTR _ltime$[ebp], eax

; 353  : 			ptm = _gmtime( (time_t *)&ltime );

  0005d	8d 4d f8	 lea	 ecx, DWORD PTR _ltime$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 __gmtime
  00066	83 c4 04	 add	 esp, 4
  00069	89 45 fc	 mov	 DWORD PTR _ptm$[ebp], eax

; 354  : 			ptm->tm_isdst = 1;

  0006c	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  0006f	c7 42 20 01 00
	00 00		 mov	 DWORD PTR [edx+32], 1
$LN5@localtime:

; 355  : 		}
; 356  : 	}

  00076	e9 a9 01 00 00	 jmp	 $LN4@localtime
$LN3@localtime:

; 357  : 	else {
; 358  : 		ptm = _gmtime( ptime );            

  0007b	8b 45 08	 mov	 eax, DWORD PTR _ptime$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 __gmtime
  00084	83 c4 04	 add	 esp, 4
  00087	89 45 fc	 mov	 DWORD PTR _ptm$[ebp], eax

; 359  : 
; 360  : 		ltime = (long)ptm->tm_sec - (_timezone + _dstbias);

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __timezone
  00090	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR __dstbias
  00096	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  00099	8b 02		 mov	 eax, DWORD PTR [edx]
  0009b	2b c1		 sub	 eax, ecx
  0009d	89 45 f8	 mov	 DWORD PTR _ltime$[ebp], eax

; 361  : 
; 362  : 		ptm->tm_sec = (int)(ltime % 60);

  000a0	8b 45 f8	 mov	 eax, DWORD PTR _ltime$[ebp]
  000a3	99		 cdq
  000a4	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000a9	f7 f9		 idiv	 ecx
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  000ae	89 10		 mov	 DWORD PTR [eax], edx

; 363  : 		if ( ptm->tm_sec < 0 ) 

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  000b3	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000b6	7d 16		 jge	 SHORT $LN6@localtime

; 364  : 		{
; 365  : 			ptm->tm_sec += 60;

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  000bb	8b 02		 mov	 eax, DWORD PTR [edx]
  000bd	83 c0 3c	 add	 eax, 60			; 0000003cH
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  000c3	89 01		 mov	 DWORD PTR [ecx], eax

; 366  : 			ltime -= 60;

  000c5	8b 55 f8	 mov	 edx, DWORD PTR _ltime$[ebp]
  000c8	83 ea 3c	 sub	 edx, 60			; 0000003cH
  000cb	89 55 f8	 mov	 DWORD PTR _ltime$[ebp], edx
$LN6@localtime:

; 367  : 		}
; 368  : 
; 369  : 		ltime = (long)ptm->tm_min + ltime/60;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _ltime$[ebp]
  000d1	99		 cdq
  000d2	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000d7	f7 f9		 idiv	 ecx
  000d9	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  000dc	03 42 04	 add	 eax, DWORD PTR [edx+4]
  000df	89 45 f8	 mov	 DWORD PTR _ltime$[ebp], eax

; 370  : 		ptm->tm_min = (int)(ltime % 60);

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _ltime$[ebp]
  000e5	99		 cdq
  000e6	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000eb	f7 f9		 idiv	 ecx
  000ed	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  000f0	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 371  : 		if ( ptm->tm_min < 0 ) 

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  000f6	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000fa	7d 18		 jge	 SHORT $LN7@localtime

; 372  : 		{
; 373  : 			ptm->tm_min += 60;

  000fc	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  000ff	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00102	83 c0 3c	 add	 eax, 60			; 0000003cH
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  00108	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 374  : 			ltime -= 60;

  0010b	8b 55 f8	 mov	 edx, DWORD PTR _ltime$[ebp]
  0010e	83 ea 3c	 sub	 edx, 60			; 0000003cH
  00111	89 55 f8	 mov	 DWORD PTR _ltime$[ebp], edx
$LN7@localtime:

; 375  : 		}
; 376  : 
; 377  : 		ltime = (long)ptm->tm_hour + ltime/60;

  00114	8b 45 f8	 mov	 eax, DWORD PTR _ltime$[ebp]
  00117	99		 cdq
  00118	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0011d	f7 f9		 idiv	 ecx
  0011f	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  00122	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00125	89 45 f8	 mov	 DWORD PTR _ltime$[ebp], eax

; 378  : 		ptm->tm_hour = (int)(ltime % 24);

  00128	8b 45 f8	 mov	 eax, DWORD PTR _ltime$[ebp]
  0012b	99		 cdq
  0012c	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00131	f7 f9		 idiv	 ecx
  00133	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  00136	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 379  : 		if ( ptm->tm_hour < 0 ) 

  00139	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  0013c	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00140	7d 18		 jge	 SHORT $LN8@localtime

; 380  : 		{
; 381  : 			ptm->tm_hour += 24;

  00142	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  00145	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00148	83 c0 18	 add	 eax, 24			; 00000018H
  0014b	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  0014e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 382  : 			ltime -=24;

  00151	8b 55 f8	 mov	 edx, DWORD PTR _ltime$[ebp]
  00154	83 ea 18	 sub	 edx, 24			; 00000018H
  00157	89 55 f8	 mov	 DWORD PTR _ltime$[ebp], edx
$LN8@localtime:

; 383  : 		}
; 384  : 
; 385  : 		ltime /= 24;

  0015a	8b 45 f8	 mov	 eax, DWORD PTR _ltime$[ebp]
  0015d	99		 cdq
  0015e	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00163	f7 f9		 idiv	 ecx
  00165	89 45 f8	 mov	 DWORD PTR _ltime$[ebp], eax

; 386  : 
; 387  : 		if ( ltime > 0L ) 

  00168	83 7d f8 00	 cmp	 DWORD PTR _ltime$[ebp], 0
  0016c	7e 37		 jle	 SHORT $LN9@localtime

; 388  : 		{
; 389  : 			ptm->tm_wday = (ptm->tm_wday + ltime) % 7;

  0016e	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  00171	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00174	03 45 f8	 add	 eax, DWORD PTR _ltime$[ebp]
  00177	99		 cdq
  00178	b9 07 00 00 00	 mov	 ecx, 7
  0017d	f7 f9		 idiv	 ecx
  0017f	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  00182	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 390  : 			ptm->tm_mday += ltime;

  00185	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  00188	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0018b	03 55 f8	 add	 edx, DWORD PTR _ltime$[ebp]
  0018e	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  00191	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 391  : 			ptm->tm_yday += ltime;

  00194	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  00197	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0019a	03 55 f8	 add	 edx, DWORD PTR _ltime$[ebp]
  0019d	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  001a0	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 392  : 		}

  001a3	eb 7f		 jmp	 SHORT $LN4@localtime
$LN9@localtime:

; 393  : 		else if ( ltime < 0L ) 

  001a5	83 7d f8 00	 cmp	 DWORD PTR _ltime$[ebp], 0
  001a9	7d 79		 jge	 SHORT $LN4@localtime

; 394  : 		{
; 395  : 			ptm->tm_wday = (ptm->tm_wday + 7 + ltime) % 7;

  001ab	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  001ae	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  001b1	8b 45 f8	 mov	 eax, DWORD PTR _ltime$[ebp]
  001b4	8d 44 02 07	 lea	 eax, DWORD PTR [edx+eax+7]
  001b8	99		 cdq
  001b9	b9 07 00 00 00	 mov	 ecx, 7
  001be	f7 f9		 idiv	 ecx
  001c0	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  001c3	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 396  : 			if ( (ptm->tm_mday += ltime) <= 0 ) 

  001c6	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  001c9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  001cc	03 55 f8	 add	 edx, DWORD PTR _ltime$[ebp]
  001cf	89 55 f4	 mov	 DWORD PTR tv162[ebp], edx
  001d2	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  001d5	8b 4d f4	 mov	 ecx, DWORD PTR tv162[ebp]
  001d8	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  001db	83 7d f4 00	 cmp	 DWORD PTR tv162[ebp], 0
  001df	7f 34		 jg	 SHORT $LN12@localtime

; 397  : 			{
; 398  : 				ptm->tm_mday += 31;

  001e1	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  001e4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001e7	83 c0 1f	 add	 eax, 31			; 0000001fH
  001ea	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  001ed	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 399  : 				ptm->tm_yday = 364;

  001f0	8b 55 fc	 mov	 edx, DWORD PTR _ptm$[ebp]
  001f3	c7 42 1c 6c 01
	00 00		 mov	 DWORD PTR [edx+28], 364	; 0000016cH

; 400  : 				ptm->tm_mon = 11;

  001fa	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  001fd	c7 40 10 0b 00
	00 00		 mov	 DWORD PTR [eax+16], 11	; 0000000bH

; 401  : 				ptm->tm_year--;

  00204	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  00207	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0020a	83 ea 01	 sub	 edx, 1
  0020d	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  00210	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 402  : 			}

  00213	eb 0f		 jmp	 SHORT $LN4@localtime
$LN12@localtime:

; 403  : 			else 
; 404  : 			{
; 405  : 				ptm->tm_yday += ltime;

  00215	8b 4d fc	 mov	 ecx, DWORD PTR _ptm$[ebp]
  00218	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0021b	03 55 f8	 add	 edx, DWORD PTR _ltime$[ebp]
  0021e	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
  00221	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN4@localtime:

; 406  : 			}
; 407  : 		}
; 408  : 	}
; 409  : 	return (ptm);

  00224	8b 45 fc	 mov	 eax, DWORD PTR _ptm$[ebp]
$LN1@localtime:

; 410  : }

  00227	8b e5		 mov	 esp, ebp
  00229	5d		 pop	 ebp
  0022a	c3		 ret	 0
__localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __gmtime
_TEXT	SEGMENT
_mdays$ = -20						; size = 4
_islpyr$ = -16						; size = 4
_ptb$ = -12						; size = 4
_tmptim$ = -8						; size = 4
_caltim$ = -4						; size = 4
_timp$ = 8						; size = 4
__gmtime PROC						; COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 254  : 
; 255  : 	long caltim = *timp;            /* calendar time to convert */

  00006	8b 45 08	 mov	 eax, DWORD PTR _timp$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d fc	 mov	 DWORD PTR _caltim$[ebp], ecx

; 256  : 	int islpyr = 0;                 /* is-current-year-a-leap-year flag */

  0000e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _islpyr$[ebp], 0

; 257  : 	int tmptim;
; 258  : 	int *mdays;                /* pointer to days or lpdays */
; 259  : 
; 260  : 	struct tm *ptb = &tb;

  00015	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ptb$[ebp], OFFSET _tb

; 261  : 
; 262  : 	if ( caltim < 0 )

  0001c	83 7d fc 00	 cmp	 DWORD PTR _caltim$[ebp], 0
  00020	7d 07		 jge	 SHORT $LN5@gmtime

; 263  : 	{
; 264  : 		return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 8c 01 00 00	 jmp	 $LN1@gmtime
$LN5@gmtime:

; 265  : 	}
; 266  : 
; 267  : 
; 268  : 	tmptim = (int)(caltim / _FOUR_YEAR_SEC);

  00029	8b 45 fc	 mov	 eax, DWORD PTR _caltim$[ebp]
  0002c	99		 cdq
  0002d	b9 80 1f 86 07	 mov	 ecx, 126230400		; 07861f80H
  00032	f7 f9		 idiv	 ecx
  00034	89 45 f8	 mov	 DWORD PTR _tmptim$[ebp], eax

; 269  : 	caltim -= ((long)tmptim * _FOUR_YEAR_SEC);

  00037	69 55 f8 80 1f
	86 07		 imul	 edx, DWORD PTR _tmptim$[ebp], 126230400
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _caltim$[ebp]
  00041	2b c2		 sub	 eax, edx
  00043	89 45 fc	 mov	 DWORD PTR _caltim$[ebp], eax

; 270  : 
; 271  : 	tmptim = (tmptim * 4) + 70;        // 

  00046	8b 4d f8	 mov	 ecx, DWORD PTR _tmptim$[ebp]
  00049	8d 14 8d 46 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+70]
  00050	89 55 f8	 mov	 DWORD PTR _tmptim$[ebp], edx

; 272  : 
; 273  : 	if ( caltim >= _YEAR_SEC ) 

  00053	81 7d fc 80 33
	e1 01		 cmp	 DWORD PTR _caltim$[ebp], 31536000 ; 01e13380H
  0005a	7c 5b		 jl	 SHORT $LN6@gmtime

; 274  : 	{
; 275  : 		tmptim++;                       

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _tmptim$[ebp]
  0005f	83 c0 01	 add	 eax, 1
  00062	89 45 f8	 mov	 DWORD PTR _tmptim$[ebp], eax

; 276  : 		caltim -= _YEAR_SEC;

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _caltim$[ebp]
  00068	81 e9 80 33 e1
	01		 sub	 ecx, 31536000		; 01e13380H
  0006e	89 4d fc	 mov	 DWORD PTR _caltim$[ebp], ecx

; 277  : 
; 278  : 		if ( caltim >= _YEAR_SEC ) 

  00071	81 7d fc 80 33
	e1 01		 cmp	 DWORD PTR _caltim$[ebp], 31536000 ; 01e13380H
  00078	7c 3d		 jl	 SHORT $LN6@gmtime

; 279  : 		{
; 280  : 
; 281  : 			tmptim++;                   

  0007a	8b 55 f8	 mov	 edx, DWORD PTR _tmptim$[ebp]
  0007d	83 c2 01	 add	 edx, 1
  00080	89 55 f8	 mov	 DWORD PTR _tmptim$[ebp], edx

; 282  : 			caltim -= _YEAR_SEC;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _caltim$[ebp]
  00086	2d 80 33 e1 01	 sub	 eax, 31536000		; 01e13380H
  0008b	89 45 fc	 mov	 DWORD PTR _caltim$[ebp], eax

; 283  : 
; 284  : 			if ( caltim >= (_YEAR_SEC + _DAY_SEC) ) 

  0008e	81 7d fc 00 85
	e2 01		 cmp	 DWORD PTR _caltim$[ebp], 31622400 ; 01e28500H
  00095	7c 17		 jl	 SHORT $LN8@gmtime

; 285  : 			{
; 286  : 
; 287  : 				tmptim++;           

  00097	8b 4d f8	 mov	 ecx, DWORD PTR _tmptim$[ebp]
  0009a	83 c1 01	 add	 ecx, 1
  0009d	89 4d f8	 mov	 DWORD PTR _tmptim$[ebp], ecx

; 288  : 				caltim -= (_YEAR_SEC + _DAY_SEC);

  000a0	8b 55 fc	 mov	 edx, DWORD PTR _caltim$[ebp]
  000a3	81 ea 00 85 e2
	01		 sub	 edx, 31622400		; 01e28500H
  000a9	89 55 fc	 mov	 DWORD PTR _caltim$[ebp], edx

; 289  : 			}

  000ac	eb 09		 jmp	 SHORT $LN6@gmtime
$LN8@gmtime:

; 290  : 			else 
; 291  : 			{
; 292  : 				islpyr++;

  000ae	8b 45 f0	 mov	 eax, DWORD PTR _islpyr$[ebp]
  000b1	83 c0 01	 add	 eax, 1
  000b4	89 45 f0	 mov	 DWORD PTR _islpyr$[ebp], eax
$LN6@gmtime:

; 293  : 			}
; 294  : 		}
; 295  : 	}
; 296  : 
; 297  : 	ptb->tm_year = tmptim;

  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _ptb$[ebp]
  000ba	8b 55 f8	 mov	 edx, DWORD PTR _tmptim$[ebp]
  000bd	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 298  : 
; 299  : 	ptb->tm_yday = (int)(caltim / _DAY_SEC);

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _caltim$[ebp]
  000c3	99		 cdq
  000c4	b9 80 51 01 00	 mov	 ecx, 86400		; 00015180H
  000c9	f7 f9		 idiv	 ecx
  000cb	8b 55 f4	 mov	 edx, DWORD PTR _ptb$[ebp]
  000ce	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 300  : 	caltim -= (long)(ptb->tm_yday) * _DAY_SEC;

  000d1	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
  000d4	69 48 1c 80 51
	01 00		 imul	 ecx, DWORD PTR [eax+28], 86400
  000db	8b 55 fc	 mov	 edx, DWORD PTR _caltim$[ebp]
  000de	2b d1		 sub	 edx, ecx
  000e0	89 55 fc	 mov	 DWORD PTR _caltim$[ebp], edx

; 301  : 
; 302  : 	if ( islpyr )

  000e3	83 7d f0 00	 cmp	 DWORD PTR _islpyr$[ebp], 0
  000e7	74 09		 je	 SHORT $LN10@gmtime

; 303  : 		mdays = _lpdays;

  000e9	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mdays$[ebp], OFFSET __lpdays
  000f0	eb 07		 jmp	 SHORT $LN11@gmtime
$LN10@gmtime:

; 304  : 	else
; 305  : 		mdays = _days;

  000f2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _mdays$[ebp], OFFSET __days
$LN11@gmtime:

; 306  : 
; 307  : 
; 308  : 	for ( tmptim = 1 ; mdays[tmptim] < ptb->tm_yday ; tmptim++ ) ;

  000f9	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _tmptim$[ebp], 1
  00100	eb 09		 jmp	 SHORT $LN4@gmtime
$LN2@gmtime:
  00102	8b 45 f8	 mov	 eax, DWORD PTR _tmptim$[ebp]
  00105	83 c0 01	 add	 eax, 1
  00108	89 45 f8	 mov	 DWORD PTR _tmptim$[ebp], eax
$LN4@gmtime:
  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _tmptim$[ebp]
  0010e	8b 55 ec	 mov	 edx, DWORD PTR _mdays$[ebp]
  00111	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
  00114	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00117	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  0011a	7d 02		 jge	 SHORT $LN3@gmtime
  0011c	eb e4		 jmp	 SHORT $LN2@gmtime
$LN3@gmtime:

; 309  : 
; 310  : 	ptb->tm_mon = --tmptim;

  0011e	8b 55 f8	 mov	 edx, DWORD PTR _tmptim$[ebp]
  00121	83 ea 01	 sub	 edx, 1
  00124	89 55 f8	 mov	 DWORD PTR _tmptim$[ebp], edx
  00127	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _tmptim$[ebp]
  0012d	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 311  : 
; 312  : 	ptb->tm_mday = ptb->tm_yday - mdays[tmptim];

  00130	8b 55 f4	 mov	 edx, DWORD PTR _ptb$[ebp]
  00133	8b 45 f8	 mov	 eax, DWORD PTR _tmptim$[ebp]
  00136	8b 4d ec	 mov	 ecx, DWORD PTR _mdays$[ebp]
  00139	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0013c	2b 14 81	 sub	 edx, DWORD PTR [ecx+eax*4]
  0013f	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
  00142	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 313  : 
; 314  : 	// 64除法需要 用的crt库
; 315  : 	ptb->tm_wday = ((int)(*timp / _DAY_SEC ) + _BASE_DOW) % 7;

  00145	8b 4d 08	 mov	 ecx, DWORD PTR _timp$[ebp]
  00148	8b 01		 mov	 eax, DWORD PTR [ecx]
  0014a	99		 cdq
  0014b	b9 80 51 01 00	 mov	 ecx, 86400		; 00015180H
  00150	f7 f9		 idiv	 ecx
  00152	83 c0 04	 add	 eax, 4
  00155	99		 cdq
  00156	b9 07 00 00 00	 mov	 ecx, 7
  0015b	f7 f9		 idiv	 ecx
  0015d	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
  00160	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 316  : 
; 317  : 	
; 318  : 	ptb->tm_hour = (int)(caltim / 3600);

  00163	8b 45 fc	 mov	 eax, DWORD PTR _caltim$[ebp]
  00166	99		 cdq
  00167	b9 10 0e 00 00	 mov	 ecx, 3600		; 00000e10H
  0016c	f7 f9		 idiv	 ecx
  0016e	8b 55 f4	 mov	 edx, DWORD PTR _ptb$[ebp]
  00171	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 319  : 	caltim -= (long)ptb->tm_hour * 3600L;

  00174	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
  00177	69 48 08 10 0e
	00 00		 imul	 ecx, DWORD PTR [eax+8], 3600
  0017e	8b 55 fc	 mov	 edx, DWORD PTR _caltim$[ebp]
  00181	2b d1		 sub	 edx, ecx
  00183	89 55 fc	 mov	 DWORD PTR _caltim$[ebp], edx

; 320  : 
; 321  : 	ptb->tm_min = (int)(caltim / 60);

  00186	8b 45 fc	 mov	 eax, DWORD PTR _caltim$[ebp]
  00189	99		 cdq
  0018a	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0018f	f7 f9		 idiv	 ecx
  00191	8b 55 f4	 mov	 edx, DWORD PTR _ptb$[ebp]
  00194	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 322  : 	ptb->tm_sec = (int)(caltim - (ptb->tm_min) * 60);

  00197	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
  0019a	6b 48 04 3c	 imul	 ecx, DWORD PTR [eax+4], 60
  0019e	8b 55 fc	 mov	 edx, DWORD PTR _caltim$[ebp]
  001a1	2b d1		 sub	 edx, ecx
  001a3	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
  001a6	89 10		 mov	 DWORD PTR [eax], edx

; 323  : 
; 324  : 	ptb->tm_isdst = 0;

  001a8	8b 4d f4	 mov	 ecx, DWORD PTR _ptb$[ebp]
  001ab	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 325  : 
; 326  : 	return (struct tm *)ptb;

  001b2	8b 45 f4	 mov	 eax, DWORD PTR _ptb$[ebp]
$LN1@gmtime:

; 327  : 
; 328  : 	//return NULL;
; 329  : }

  001b5	8b e5		 mov	 esp, ebp
  001b7	5d		 pop	 ebp
  001b8	c3		 ret	 0
__gmtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __ctime
_TEXT	SEGMENT
_tmtemp$ = -4						; size = 4
_timp$ = 8						; size = 4
__ctime	PROC						; COMDAT

; 465  :  {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 466  :  	struct tm *tmtemp;
; 467  :  
; 468  : 	tmtemp =_localtime(timp); 

  00004	8b 45 08	 mov	 eax, DWORD PTR _timp$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 __localtime
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 fc	 mov	 DWORD PTR _tmtemp$[ebp], eax

; 469  :  	if( tmtemp != NULL)

  00013	83 7d fc 00	 cmp	 DWORD PTR _tmtemp$[ebp], 0
  00017	74 10		 je	 SHORT $LN2@ctime

; 470  :  	{
; 471  :  		return(_asctime((const struct tm *)tmtemp));

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _tmtemp$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 __asctime
  00022	83 c4 04	 add	 esp, 4
  00025	eb 04		 jmp	 SHORT $LN1@ctime

; 472  :  	}

  00027	eb 02		 jmp	 SHORT $LN1@ctime
$LN2@ctime:

; 473  :  	else
; 474  :  	{
; 475  :  		return NULL;

  00029	33 c0		 xor	 eax, eax
$LN1@ctime:

; 476  : 	}
; 477  :  }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
__ctime	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __asctime
_TEXT	SEGMENT
_tb$ = 8						; size = 4
__asctime PROC						; COMDAT

; 427  :   {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  :  //	char *p = buf;
; 429  :   	//int day, mon;
; 430  :   	//int i;
; 431  :  
; 432  :  
; 433  :  // 	
; 434  :  // 
; 435  :  // 	day = tb->tm_wday * 3;          /* index to correct day string */
; 436  :  // 	mon = tb->tm_mon * 3;           /* index to correct month string */
; 437  :  // 	for (i=0; i < 3; i++,p++) 
; 438  :  // 	{
; 439  :  // 		*p = *(__dnames + day + i);
; 440  :  // 		*(p+4) = *(__mnames + mon + i);
; 441  :  // 	}
; 442  :  // 
; 443  :  // 	*p = ' ';                   /* blank between day and month */
; 444  :  // 
; 445  :  // 	p += 4;
; 446  :  // 
; 447  :  // 	*p++ = ' ';
; 448  :  // 	p = store_dt(p, tb->tm_mday);   /* day of the month (1-31) */
; 449  :  // 	*p++ = ' ';
; 450  :  // 	p = store_dt(p, tb->tm_hour);   /* hours (0-23) */
; 451  :  // 	*p++ = ':';
; 452  :  // 	p = store_dt(p, tb->tm_min);    /* minutes (0-59) */
; 453  :  // 	*p++ = ':';
; 454  :  // 	p = store_dt(p, tb->tm_sec);    /* seconds (0-59) */
; 455  :  // 	*p++ = ' ';
; 456  :  // 	p = store_dt(p, 19 + (tb->tm_year/100)); /* year (after 1900) */
; 457  :  // 	p = store_dt(p, tb->tm_year%100);
; 458  :  // 	*p++ = '\n';
; 459  :  // 	*p = '\0';
; 460  :  
; 461  :  	return NULL;

  00003	33 c0		 xor	 eax, eax

; 462  :  }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
__asctime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __mktime
_TEXT	SEGMENT
_p$ = 8							; size = 4
__mktime PROC						; COMDAT

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 249  :  	return( _make_time_t(p, 1) );

  00003	6a 01		 push	 1
  00005	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 __make_time_t
  0000e	83 c4 08	 add	 esp, 8

; 250  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
__mktime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __difftime
_TEXT	SEGMENT
_b$ = 8							; size = 4
_a$ = 12						; size = 4
__difftime PROC						; COMDAT

; 413  :    {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 414  :    	return( ( b - a ) ); 

  00003	8b 45 08	 mov	 eax, DWORD PTR _b$[ebp]
  00006	2b 45 0c	 sub	 eax, DWORD PTR _a$[ebp]

; 415  :    }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
__difftime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT __time
_TEXT	SEGMENT
_szDate$ = -12						; size = 6
_tim$ = -4						; size = 4
_tptr$ = 8						; size = 4
__time	PROC						; COMDAT

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 234  : 	BYTE  szDate[6];
; 235  : 	time_t tim;
; 236  : 
; 237  :  	GetSystemTime(szDate);

  00006	8d 45 f4	 lea	 eax, DWORD PTR _szDate$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _GetSystemTime
  0000f	83 c4 04	 add	 esp, 4

; 238  :  	tim = _gmtotime_t(szDate[0] + 2000,szDate[1],szDate[2],szDate[3],szDate[4],szDate[5]);

  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	6b d1 05	 imul	 edx, ecx, 5
  0001a	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _szDate$[ebp+edx]
  0001f	50		 push	 eax
  00020	b9 01 00 00 00	 mov	 ecx, 1
  00025	c1 e1 02	 shl	 ecx, 2
  00028	0f b6 54 0d f4	 movzx	 edx, BYTE PTR _szDate$[ebp+ecx]
  0002d	52		 push	 edx
  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	6b c8 03	 imul	 ecx, eax, 3
  00036	0f b6 54 0d f4	 movzx	 edx, BYTE PTR _szDate$[ebp+ecx]
  0003b	52		 push	 edx
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	d1 e0		 shl	 eax, 1
  00043	0f b6 4c 05 f4	 movzx	 ecx, BYTE PTR _szDate$[ebp+eax]
  00048	51		 push	 ecx
  00049	ba 01 00 00 00	 mov	 edx, 1
  0004e	c1 e2 00	 shl	 edx, 0
  00051	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _szDate$[ebp+edx]
  00056	50		 push	 eax
  00057	b9 01 00 00 00	 mov	 ecx, 1
  0005c	6b d1 00	 imul	 edx, ecx, 0
  0005f	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _szDate$[ebp+edx]
  00064	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 __gmtotime_t
  0006f	83 c4 18	 add	 esp, 24			; 00000018H
  00072	89 45 fc	 mov	 DWORD PTR _tim$[ebp], eax

; 239  :  
; 240  :  	if( tptr )

  00075	83 7d 08 00	 cmp	 DWORD PTR _tptr$[ebp], 0
  00079	74 08		 je	 SHORT $LN2@time

; 241  :  	{
; 242  :  		*tptr = tim;

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _tptr$[ebp]
  0007e	8b 55 fc	 mov	 edx, DWORD PTR _tim$[ebp]
  00081	89 11		 mov	 DWORD PTR [ecx], edx
$LN2@time:

; 243  :  	}
; 244  :  	return tim;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _tim$[ebp]

; 245  : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
__time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\time.c
;	COMDAT _clock
_TEXT	SEGMENT
_clock	PROC						; COMDAT

; 485  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 486  : 	//return _time(NULL);
; 487  : 	return 0;

  00003	33 c0		 xor	 eax, eax
  00005	33 d2		 xor	 edx, edx

; 488  : }

  00007	5d		 pop	 ebp
  00008	c3		 ret	 0
_clock	ENDP
_TEXT	ENDS
END
